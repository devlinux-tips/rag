"""
Multi-tenant folder management utilities with dependency injection.
100% testable version with pure functions and dependency injection architecture.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Protocol, Tuple

from ..models.multitenant_models import (DocumentScope, Tenant,
                                         TenantUserContext, User)

# ================================
# DATA CLASSES & CONFIGURATION
# ================================


@dataclass
class FolderConfig:
    """Configuration for folder management operations."""

    data_base_dir: str
    models_base_dir: str
    system_dir: str
    tenant_root_template: str
    user_documents_template: str
    tenant_shared_template: str
    user_processed_template: str
    tenant_processed_template: str
    chromadb_path_template: str
    models_path_template: str
    collection_name_template: str


@dataclass
class FolderStats:
    """Statistics for folder usage."""

    count: int = 0
    size_bytes: int = 0


@dataclass
class TenantStats:
    """Complete statistics for a tenant."""

    documents: FolderStats
    processed: FolderStats
    models: FolderStats
    chromadb: FolderStats


@dataclass
class FolderPaths:
    """Complete folder structure for a tenant/user/language combination."""

    tenant_root: Path
    tenant_cache: Optional[Path] = None
    tenant_exports: Optional[Path] = None
    tenant_logs: Optional[Path] = None
    tenant_chromadb: Optional[Path] = None
    tenant_shared_documents_lang: Optional[Path] = None
    tenant_shared_processed_lang: Optional[Path] = None
    user_root: Optional[Path] = None
    user_exports: Optional[Path] = None
    user_cache: Optional[Path] = None
    user_documents_raw: Optional[Path] = None
    user_documents_lang: Optional[Path] = None
    user_processed_lang: Optional[Path] = None
    tenant_models_lang: Optional[Path] = None
    tenant_models_embeddings: Optional[Path] = None
    tenant_models_generation: Optional[Path] = None
    tenant_models: Optional[Path] = None
    tenant_models_shared: Optional[Path] = None


@dataclass
class CollectionPaths:
    """ChromaDB collection paths and names."""

    user_collection_name: str
    tenant_collection_name: str
    user_collection_path: Path
    tenant_collection_path: Path
    base_path: Path


# ================================
# DEPENDENCY INJECTION PROTOCOLS
# ================================


class FileSystemProvider(Protocol):
    """Protocol for filesystem operations."""

    def create_folder(self, folder_path: Path) -> bool:
        """Create a folder if it doesn't exist."""
        ...

    def folder_exists(self, folder_path: Path) -> bool:
        """Check if folder exists."""
        ...

    def remove_folder(self, folder_path: Path) -> bool:
        """Remove folder and all contents."""
        ...

    def get_folder_stats(self, folder_path: Path) -> FolderStats:
        """Get file count and size statistics for folder."""
        ...


class ConfigProvider(Protocol):
    """Protocol for configuration access."""

    def get_folder_config(self) -> FolderConfig:
        """Get folder configuration."""
        ...


class LoggerProvider(Protocol):
    """Protocol for logging operations."""

    def info(self, message: str) -> None:
        """Log info message."""
        ...

    def debug(self, message: str) -> None:
        """Log debug message."""
        ...

    def warning(self, message: str) -> None:
        """Log warning message."""
        ...

    def error(self, message: str) -> None:
        """Log error message."""
        ...


# ================================
# PURE BUSINESS LOGIC FUNCTIONS
# ================================


def render_path_template(template: str, **kwargs) -> str:
    """Pure function to render a path template with given parameters."""
    return template.format(**kwargs)


def build_template_params(
    tenant: Tenant,
    user: Optional[User] = None,
    language: Optional[str] = None,
    config: FolderConfig = None,
) -> Dict[str, str]:
    """Pure function to build template parameters for path rendering."""
    params = {
        "tenant_slug": tenant.slug,
        "language": language or "default",
    }

    if user:
        params["user_id"] = user.username

    if config:
        params.update(
            {
                "data_base_dir": config.data_base_dir,
                "models_base_dir": config.models_base_dir,
                "system_dir": config.system_dir,
            }
        )

    return params


def calculate_folder_structure(
    tenant: Tenant, user: Optional[User], language: Optional[str], config: FolderConfig
) -> FolderPaths:
    """Pure function to calculate complete folder structure."""
    params = build_template_params(tenant, user, language, config)

    # Render tenant root
    tenant_root_str = render_path_template(config.tenant_root_template, **params)
    tenant_root = Path(tenant_root_str)

    # Build folder paths structure
    paths = FolderPaths(tenant_root=tenant_root)

    # Core tenant folders (direct construction)
    paths.tenant_cache = tenant_root / "cache"
    paths.tenant_exports = tenant_root / "exports"
    paths.tenant_logs = tenant_root / "logs"

    # ChromaDB path using template
    chromadb_str = render_path_template(config.chromadb_path_template, **params)
    paths.tenant_chromadb = Path(chromadb_str)

    # Language-specific tenant folders
    if language:
        tenant_shared_str = render_path_template(
            config.tenant_shared_template, **params
        )
        paths.tenant_shared_documents_lang = Path(tenant_shared_str)

        tenant_processed_str = render_path_template(
            config.tenant_processed_template, **params
        )
        paths.tenant_shared_processed_lang = Path(tenant_processed_str)

    # User-specific folders
    if user:
        user_root = tenant_root / "users" / user.username
        paths.user_root = user_root
        paths.user_exports = user_root / "exports"
        paths.user_cache = user_root / "cache"
        paths.user_documents_raw = user_root / "documents" / "raw"

        # Language-specific user folders
        if language:
            user_documents_str = render_path_template(
                config.user_documents_template, **params
            )
            paths.user_documents_lang = Path(user_documents_str)

            user_processed_str = render_path_template(
                config.user_processed_template, **params
            )
            paths.user_processed_lang = Path(user_processed_str)

    # Model folders
    if language:
        models_str = render_path_template(config.models_path_template, **params)
        models_path = Path(models_str)
        paths.tenant_models_lang = models_path
        paths.tenant_models_embeddings = models_path / "embeddings"
        paths.tenant_models_generation = models_path / "generation"

    # Tenant models root (no language)
    models_root = Path(config.models_base_dir) / tenant.slug
    paths.tenant_models = models_root
    paths.tenant_models_shared = models_root / "shared"

    return paths


def calculate_document_path(
    context: TenantUserContext,
    language: str,
    scope: DocumentScope,
    config: FolderConfig,
) -> Path:
    """Pure function to calculate document storage path."""
    paths = calculate_folder_structure(context.tenant, context.user, language, config)

    if scope == DocumentScope.USER:
        return paths.user_documents_lang
    else:  # DocumentScope.TENANT
        return paths.tenant_shared_documents_lang


def calculate_processed_path(
    context: TenantUserContext,
    language: str,
    scope: DocumentScope,
    config: FolderConfig,
) -> Path:
    """Pure function to calculate processed data storage path."""
    paths = calculate_folder_structure(context.tenant, context.user, language, config)

    if scope == DocumentScope.USER:
        return paths.user_processed_lang
    else:  # DocumentScope.TENANT
        return paths.tenant_shared_processed_lang


def calculate_chromadb_path(tenant: Tenant, config: FolderConfig) -> Path:
    """Pure function to calculate ChromaDB storage path."""
    params = build_template_params(tenant, config=config)
    chromadb_str = render_path_template(config.chromadb_path_template, **params)
    return Path(chromadb_str)


def calculate_models_path(
    tenant: Tenant, language: str, model_type: str, config: FolderConfig
) -> Path:
    """Pure function to calculate model storage path."""
    params = build_template_params(tenant, language=language, config=config)
    models_str = render_path_template(config.models_path_template, **params)
    return Path(models_str) / model_type


def calculate_collection_paths(
    context: TenantUserContext, language: str, config: FolderConfig
) -> CollectionPaths:
    """Pure function to calculate ChromaDB collection paths and names."""
    chromadb_base = calculate_chromadb_path(context.tenant, config)
    params = build_template_params(context.tenant, config=config)

    # Calculate collection names
    user_params = {**params, "scope": "user", "language": language}
    tenant_params = {**params, "scope": "tenant", "language": language}

    user_collection = render_path_template(
        config.collection_name_template, **user_params
    )
    tenant_collection = render_path_template(
        config.collection_name_template, **tenant_params
    )

    return CollectionPaths(
        user_collection_name=user_collection,
        tenant_collection_name=tenant_collection,
        user_collection_path=chromadb_base / user_collection,
        tenant_collection_path=chromadb_base / tenant_collection,
        base_path=chromadb_base,
    )


def get_system_paths(config: FolderConfig) -> List[Path]:
    """Pure function to get system folder paths."""
    system_dir = Path(config.system_dir)
    return [system_dir / "logs", system_dir / "backups", system_dir / "temp"]


def get_all_folder_paths(paths: FolderPaths) -> List[Path]:
    """Pure function to extract all non-None paths from FolderPaths structure."""
    all_paths = []
    for field_name, field_value in paths.__dict__.items():
        if field_value is not None:
            all_paths.append(field_value)
    return all_paths


def calculate_tenant_cleanup_paths(tenant: Tenant, config: FolderConfig) -> List[Path]:
    """Pure function to calculate paths that need to be cleaned up for a tenant."""
    params = build_template_params(tenant, config=config)
    tenant_root_str = render_path_template(config.tenant_root_template, **params)
    tenant_root = Path(tenant_root_str)
    models_root = Path(config.models_base_dir) / tenant.slug

    return [tenant_root, models_root]


def calculate_usage_stats_paths(
    tenant: Tenant, config: FolderConfig
) -> Dict[str, Path]:
    """Pure function to calculate paths for usage statistics."""
    params = build_template_params(tenant, config=config)
    tenant_root_str = render_path_template(config.tenant_root_template, **params)
    tenant_root = Path(tenant_root_str)
    models_root = Path(config.models_base_dir) / tenant.slug
    chromadb_str = render_path_template(config.chromadb_path_template, **params)

    return {
        "documents": tenant_root / "users",
        "processed": tenant_root / "shared",
        "chromadb": Path(chromadb_str),
        "models": models_root,
    }


# ================================
# DEPENDENCY INJECTION ORCHESTRATION
# ================================


class _TenantFolderManager:
    """100% testable tenant folder manager with dependency injection."""

    def __init__(
        self,
        config_provider: ConfigProvider,
        filesystem_provider: FileSystemProvider,
        logger_provider: Optional[LoggerProvider] = None,
    ):
        """Initialize with injected dependencies."""
        self._config_provider = config_provider
        self._filesystem_provider = filesystem_provider
        self._logger = logger_provider
        self._config = None

    def _get_config(self) -> FolderConfig:
        """Get configuration with caching."""
        if self._config is None:
            self._config = self._config_provider.get_folder_config()
        return self._config

    def _log_info(self, message: str) -> None:
        """Log info message if logger available."""
        if self._logger:
            self._logger.info(message)

    def _log_debug(self, message: str) -> None:
        """Log debug message if logger available."""
        if self._logger:
            self._logger.debug(message)

    def _log_warning(self, message: str) -> None:
        """Log warning message if logger available."""
        if self._logger:
            self._logger.warning(message)

    def _log_error(self, message: str) -> None:
        """Log error message if logger available."""
        if self._logger:
            self._logger.error(message)

    def get_tenant_folder_structure(
        self,
        tenant: Tenant,
        user: Optional[User] = None,
        language: Optional[str] = None,
    ) -> FolderPaths:
        """Get complete folder structure for tenant/user/language combination."""
        config = self._get_config()
        return calculate_folder_structure(tenant, user, language, config)

    def create_tenant_folder_structure(
        self,
        tenant: Tenant,
        user: Optional[User] = None,
        languages: Optional[List[str]] = None,
    ) -> Tuple[bool, List[str]]:
        """Create complete folder structure for tenant/user/languages."""
        created_folders = []

        try:
            config = self._get_config()

            # Get supported languages if not provided
            if languages is None:
                languages = tenant.get_supported_languages()

            self._log_info(
                f"Creating folder structure for tenant: {tenant.slug}, user: {user.username if user else None}, languages: {languages}"
            )

            # Create base structure for each language
            for language in languages:
                paths = calculate_folder_structure(tenant, user, language, config)

                # Create all paths
                for folder_path in get_all_folder_paths(paths):
                    if self._filesystem_provider.create_folder(folder_path):
                        created_folders.append(str(folder_path))
                        self._log_debug(f"Created folder: {folder_path}")

            # Create system folders if needed
            system_paths = get_system_paths(config)
            for system_path in system_paths:
                if self._filesystem_provider.create_folder(system_path):
                    created_folders.append(str(system_path))

            self._log_info(
                f"Successfully created {len(created_folders)} folders for tenant structure"
            )
            return True, created_folders

        except Exception as e:
            self._log_error(f"Failed to create tenant folder structure: {e}")
            return False, created_folders

    def get_tenant_document_path(
        self,
        context: TenantUserContext,
        language: str,
        scope: DocumentScope,
        create_if_missing: bool = True,
    ) -> Path:
        """Get document storage path for specific tenant/user/language/scope."""
        config = self._get_config()
        doc_path = calculate_document_path(context, language, scope, config)

        if create_if_missing and doc_path:
            self._filesystem_provider.create_folder(doc_path)

        return doc_path

    def get_tenant_processed_path(
        self,
        context: TenantUserContext,
        language: str,
        scope: DocumentScope,
        create_if_missing: bool = True,
    ) -> Path:
        """Get processed data storage path for specific tenant/user/language/scope."""
        config = self._get_config()
        processed_path = calculate_processed_path(context, language, scope, config)

        if create_if_missing and processed_path:
            self._filesystem_provider.create_folder(processed_path)

        return processed_path

    def get_tenant_chromadb_path(
        self, tenant: Tenant, create_if_missing: bool = True
    ) -> Path:
        """Get ChromaDB storage path for tenant."""
        config = self._get_config()
        chromadb_path = calculate_chromadb_path(tenant, config)

        if create_if_missing:
            self._filesystem_provider.create_folder(chromadb_path)

        return chromadb_path

    def get_tenant_models_path(
        self,
        tenant: Tenant,
        language: str,
        model_type: str = "embeddings",
        create_if_missing: bool = True,
    ) -> Path:
        """Get model storage path for tenant/language."""
        config = self._get_config()
        models_path = calculate_models_path(tenant, language, model_type, config)

        if create_if_missing:
            self._filesystem_provider.create_folder(models_path)

        return models_path

    def get_collection_storage_paths(
        self, context: TenantUserContext, language: str
    ) -> CollectionPaths:
        """Get all ChromaDB collection storage paths for a tenant/user/language."""
        config = self._get_config()
        return calculate_collection_paths(context, language, config)

    def ensure_context_folders(self, context: TenantUserContext, language: str) -> bool:
        """Ensure all necessary folders exist for a tenant/user/language context."""
        try:
            # Create tenant and user folder structure
            success, folders = self.create_tenant_folder_structure(
                context.tenant, context.user, [language]
            )

            if success:
                self._log_info(
                    f"Ensured folder structure for {context.tenant.slug}/{context.user.username}/{language}"
                )
                return True
            else:
                self._log_error("Failed to ensure folder structure for context")
                return False

        except Exception as e:
            self._log_error(f"Error ensuring context folders: {e}")
            return False

    def cleanup_tenant_folders(self, tenant: Tenant, confirm: bool = False) -> bool:
        """Clean up all folders for a tenant. USE WITH CAUTION."""
        if not confirm:
            self._log_warning(
                "Cleanup requires explicit confirmation. Set confirm=True"
            )
            return False

        try:
            config = self._get_config()
            cleanup_paths = calculate_tenant_cleanup_paths(tenant, config)

            for path in cleanup_paths:
                if self._filesystem_provider.folder_exists(path):
                    if self._filesystem_provider.remove_folder(path):
                        self._log_info(f"Cleaned up folder: {path}")
                    else:
                        self._log_error(f"Failed to clean up folder: {path}")
                        return False

            return True

        except Exception as e:
            self._log_error(f"Failed to cleanup tenant folders: {e}")
            return False

    def get_folder_usage_stats(self, tenant: Tenant) -> TenantStats:
        """Get storage usage statistics for tenant."""
        try:
            config = self._get_config()
            stats_paths = calculate_usage_stats_paths(tenant, config)

            stats = TenantStats(
                documents=FolderStats(),
                processed=FolderStats(),
                models=FolderStats(),
                chromadb=FolderStats(),
            )

            # Get stats for each path type
            for stat_type, path in stats_paths.items():
                if self._filesystem_provider.folder_exists(path):
                    folder_stats = self._filesystem_provider.get_folder_stats(path)
                    setattr(stats, stat_type, folder_stats)

            return stats

        except Exception as e:
            self._log_error(f"Error getting folder stats: {e}")
            return TenantStats(
                documents=FolderStats(),
                processed=FolderStats(),
                models=FolderStats(),
                chromadb=FolderStats(),
            )


# ================================
# CONVENIENCE FACTORY FUNCTIONS
# ================================


def create_tenant_folder_manager(
    config_provider: ConfigProvider,
    filesystem_provider: FileSystemProvider,
    logger_provider: Optional[LoggerProvider] = None,
) -> _TenantFolderManager:
    """Factory function to create configured TenantFolderManager."""
    return _TenantFolderManager(
        config_provider=config_provider,
        filesystem_provider=filesystem_provider,
        logger_provider=logger_provider,
    )


# ================================
# PUBLIC INTERFACE
# ================================


def TenantFolderManager(
    """Legacy folder manager for backward compatibility."""

    def __init__(self, base_config: Optional[Dict] = None):
        """Initialize with legacy interface pattern."""
        from .folder_manager_providers import create_production_setup

        # Create DI components
        (
            config_provider,
            filesystem_provider,
            logger_provider,
        ) = create_production_setup()

        # Create modern manager
        self._manager = _TenantFolderManager(
            config_provider=config_provider,
            filesystem_provider=filesystem_provider,
            logger_provider=logger_provider,
        )

        # Store legacy config for compatibility
        self.config = base_config
        if base_config:
            # If custom config provided, we'd need to create a custom config provider
            # For now, use the default production setup
            pass

    def get_tenant_folder_structure(
        self,
        tenant: Tenant,
        user: Optional[User] = None,
        language: Optional[str] = None,
    ) -> Dict[str, Path]:
        """Legacy method that returns Dict[str, Path] instead of FolderPaths."""
        folder_paths = self._manager.get_tenant_folder_structure(tenant, user, language)

        # Convert FolderPaths to legacy Dict[str, Path] format
        result = {}
        for field_name, field_value in folder_paths.__dict__.items():
            if field_value is not None:
                result[field_name] = field_value

        return result

    def create_tenant_folder_structure(
        self,
        tenant: Tenant,
        user: Optional[User] = None,
        languages: Optional[List[str]] = None,
    ) -> Tuple[bool, List[str]]:
        """Legacy method interface."""
        return self._manager.create_tenant_folder_structure(tenant, user, languages)

    def get_tenant_document_path(
        self,
        context: TenantUserContext,
        language: str,
        scope: DocumentScope,
        create_if_missing: bool = True,
    ) -> Path:
        """Legacy method interface."""
        return self._manager.get_tenant_document_path(
            context, language, scope, create_if_missing
        )

    def get_tenant_processed_path(
        self,
        context: TenantUserContext,
        language: str,
        scope: DocumentScope,
        create_if_missing: bool = True,
    ) -> Path:
        """Legacy method interface."""
        return self._manager.get_tenant_processed_path(
            context, language, scope, create_if_missing
        )

    def get_tenant_chromadb_path(
        self, tenant: Tenant, create_if_missing: bool = True
    ) -> Path:
        """Legacy method interface."""
        return self._manager.get_tenant_chromadb_path(tenant, create_if_missing)

    def get_tenant_models_path(
        self,
        tenant: Tenant,
        language: str,
        model_type: str = "embeddings",
        create_if_missing: bool = True,
    ) -> Path:
        """Legacy method interface."""
        return self._manager.get_tenant_models_path(
            tenant, language, model_type, create_if_missing
        )

    def get_collection_storage_paths(
        self, context: TenantUserContext, language: str
    ) -> Dict[str, Path]:
        """Legacy method that returns paths in dict format."""
        collection_paths = self._manager.get_collection_storage_paths(context, language)

        return {
            "user_collection_name": collection_paths.user_collection_name,
            "tenant_collection_name": collection_paths.tenant_collection_name,
            "user_collection_path": collection_paths.user_collection_path,
            "tenant_collection_path": collection_paths.tenant_collection_path,
            "base_path": collection_paths.base_path,
        }

    def ensure_context_folders(self, context: TenantUserContext, language: str) -> bool:
        """Legacy method interface."""
        return self._manager.ensure_context_folders(context, language)

    def cleanup_tenant_folders(self, tenant: Tenant, confirm: bool = False) -> bool:
        """Legacy method interface."""
        return self._manager.cleanup_tenant_folders(tenant, confirm)

    def get_folder_usage_stats(self, tenant: Tenant) -> Dict[str, Dict[str, int]]:
        """Legacy method that returns stats in dict format."""
        tenant_stats = self._manager.get_folder_usage_stats(tenant)

        return {
            "documents": {
                "count": tenant_stats.documents.count,
                "size_bytes": tenant_stats.documents.size_bytes,
            },
            "processed": {
                "count": tenant_stats.processed.count,
                "size_bytes": tenant_stats.processed.size_bytes,
            },
            "models": {
                "count": tenant_stats.models.count,
                "size_bytes": tenant_stats.models.size_bytes,
            },
            "chromadb": {
                "count": tenant_stats.chromadb.count,
                "size_bytes": tenant_stats.chromadb.size_bytes,
            },
        }


# ================================
# LEGACY CONVENIENCE FUNCTIONS
# ================================


def create_development_structure() -> bool:
    """Create default development tenant/user structure for testing."""
    from ..models.multitenant_models import (DEFAULT_DEVELOPMENT_TENANT,
                                             DEFAULT_DEVELOPMENT_USER)
    from .folder_manager_providers import create_production_setup

    config_provider, filesystem_provider, logger_provider = create_production_setup()
    folder_manager = _TenantFolderManager(
        config_provider=config_provider,
        filesystem_provider=filesystem_provider,
        logger_provider=logger_provider,
    )

    # Create structure for development tenant with default user
    success, folders = folder_manager.create_tenant_folder_structure(
        tenant=DEFAULT_DEVELOPMENT_TENANT,
        user=DEFAULT_DEVELOPMENT_USER,
        languages=["hr", "en", "multilingual"],
    )

    if success and logger_provider:
        logger_provider.info(
            f"Created development structure with {len(folders)} folders"
        )
        logger_provider.info("Ready for user-level multi-tenant testing")
    elif not success and logger_provider:
        logger_provider.error("Failed to create development structure")

    return success


def ensure_tenant_context_ready(context: TenantUserContext, language: str) -> bool:
    """Ensure all folders are ready for a specific tenant/user/language context."""
    from .folder_manager_providers import create_production_setup

    config_provider, filesystem_provider, logger_provider = create_production_setup()
    folder_manager = _TenantFolderManager(
        config_provider=config_provider,
        filesystem_provider=filesystem_provider,
        logger_provider=logger_provider,
    )
    return folder_manager.ensure_context_folders(context, language)


def get_user_document_folder(context: TenantUserContext, language: str) -> Path:
    """Get user's document folder path."""
    from .folder_manager_providers import create_production_setup

    config_provider, filesystem_provider, logger_provider = create_production_setup()
    folder_manager = _TenantFolderManager(
        config_provider=config_provider,
        filesystem_provider=filesystem_provider,
        logger_provider=logger_provider,
    )
    return folder_manager.get_tenant_document_path(
        context, language, DocumentScope.USER
    )


def get_tenant_document_folder(context: TenantUserContext, language: str) -> Path:
    """Get tenant's shared document folder path."""
    from .folder_manager_providers import create_production_setup

    config_provider, filesystem_provider, logger_provider = create_production_setup()
    folder_manager = _TenantFolderManager(
        config_provider=config_provider,
        filesystem_provider=filesystem_provider,
        logger_provider=logger_provider,
    )
    return folder_manager.get_tenant_document_path(
        context, language, DocumentScope.TENANT
    )


def get_user_chromadb_collections(
    context: TenantUserContext, language: str
) -> Dict[str, str]:
    """Get ChromaDB collection names for user context."""
    return {
        "user_collection": context.get_user_collection_name(language),
        "tenant_collection": context.get_tenant_collection_name(language),
        "search_collections": context.get_search_collections(language),
    }


# ================================
# BACKWARD COMPATIBILITY FACTORY
# ================================


def create_legacy_folder_manager(
    base_config: Optional[Dict] = None,
) -> LegacyTenantFolderManager:
    """Create folder manager using legacy interface for backward compatibility."""
    return LegacyTenantFolderManager(base_config)


# ================================
# DUAL INTERFACE SUPPORT
# ================================


# For new code: use create_tenant_folder_manager() with DI
# For legacy code: TenantFolderManager() constructor is mapped to legacy version
def TenantFolderManager(
    base_config: Optional[Dict] = None,
    config_provider: Optional[ConfigProvider] = None,
    filesystem_provider: Optional[FileSystemProvider] = None,
    logger_provider: Optional[LoggerProvider] = None,
):
    """
    Unified TenantFolderManager factory supporting both interfaces.

    Legacy interface (for backward compatibility):
        TenantFolderManager(base_config=None)

    New DI interface:
        TenantFolderManager(config_provider=provider, filesystem_provider=provider, ...)
    """
    # New DI interface - all DI components provided
    if config_provider and filesystem_provider:
        return _TenantFolderManager(
            config_provider=config_provider,
            filesystem_provider=filesystem_provider,
            logger_provider=logger_provider,
        )

    # Legacy interface - only base_config provided (or nothing)
    else:
        return LegacyTenantFolderManager(base_config)
